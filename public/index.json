
[{"content":"","date":"5 August 2024","externalUrl":null,"permalink":"/danirybeblog/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"5 August 2024","externalUrl":null,"permalink":"/danirybeblog/","section":"Dani Rybe's Blog","summary":"","title":"Dani Rybe's Blog","type":"page"},{"content":"","date":"5 August 2024","externalUrl":null,"permalink":"/danirybeblog/tags/newcombs-paradox/","section":"Tags","summary":"","title":"Newcombs-Paradox","type":"tags"},{"content":"","date":"5 August 2024","externalUrl":null,"permalink":"/danirybeblog/categories/paradoxes/","section":"Categories","summary":"","title":"Paradoxes","type":"categories"},{"content":"","date":"5 August 2024","externalUrl":null,"permalink":"/danirybeblog/categories/philosophy/","section":"Categories","summary":"","title":"Philosophy","type":"categories"},{"content":"","date":"5 August 2024","externalUrl":null,"permalink":"/danirybeblog/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"5 August 2024","externalUrl":null,"permalink":"/danirybeblog/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"Recently, I had my curiosity intrigued by Newcomb\u0026rsquo;s paradox, which is a philosophical paradox devised by William Newcomb in 1960. I was never that great at introductions, so let me just shamelessly copy its description from Wikipedia to get everybody up to speed.\nThe problem # There is a reliable predictor, another player, and two boxes designated A and B. The player is given a choice between taking only box B or taking both boxes A and B. The player knows the following:\nBox A is transparent and always contains visible $1,000.\nBox B is opaque, and its content has already been set by the predictor:\nIf the predictor has predicted that the player will take both boxes A and B, then box B contains nothing.\nIf the predictor has predicted that the player will take only box B, then box B contains $1,000,000.\nThe player does not know what the predictor predicted or what box B contains while making the choice. The question is, what choice should they make to maximize the amount of money they get?\nThe paradox arises from the fact that it\u0026rsquo;s possible to construct seemingly airtight arguments in favor of both choices:\nOf course you should only take box B! I have seen this game show in the past. Every time a player chooses both boxes, they leave with only $1,000, and every time they choose only box B, they leave with a million! The predictor IS reliable after all.\n— boxB_enjoyer420 You sweet, sweet summer child\u0026hellip; obviously you should take both boxes! The amount of money in box B has already been decided, so by taking both boxes you get whatever is in box B, plus an additional $1000! It\u0026rsquo;s a strictly better choice.\n— ₓxXbothBoxesEnthusiastXxₓ Both of these positions, at least to me, seem completely reasonable, which is a problem.\nOf course, there is a third position that one may take:\nThis game show is so fake, and you two are too stupid to see it. It\u0026rsquo;s impossible to create a perfectly reliable predictor, so all your squabbles are completely meaningless.\n— \\_TheEnlightenedSceptic_ This solution, though, isn\u0026rsquo;t very satisfying, isn\u0026rsquo;t it?\nEven if it\u0026rsquo;s impossible to perfectly predict a person\u0026rsquo;s choice due to quantum mechanics/free will/god/etc,\nI\u0026rsquo;m not at all sure that any of those things are strictly necessary for the existence of human-like conscious observers.\nSo here\u0026rsquo;s my attempt at resolving this paradox. Hopefully it\u0026rsquo;s interesting.\nProposed solution # So, imagine for a second a scenario where you agree to trip sit me. I, having taken an ungodly amount of shrooms, start seeing aliens in the sky and decide that the most rational course of action is to take my rifle and start shooting at them in an attempt to save the world. From my perspective, this seems like a rational thing to do, but I shouldn\u0026rsquo;t really do it of course, and you, as a sober person, agree.\nThis may seem like a random tangent, but I think that\u0026rsquo;s exactly what happens in the paradox scenario. The players perception of reality gets compromised in a subtle way and as a result, they perceive an apparent breakage of causality and an irrational choice of taking both boxes appears rational.\nBut how would their perception be compromised without their brain chemistry changing in some way? This is where it gets interesting. I\u0026rsquo;d argue that the process of predicting their choice is already enough. The device in question would need to collect a lot of information from inside the players brain in order to predict their choice. Information that the brain can normally assume to be isolated. And that changes the relationship between the brain and the outside world enough for the illusion of reality to break. In the presence of this unnatural, uncontrolled information tunnel, the brain fails to construct a convincing representation of reality, while allowing the player to pretend that they are an independent conscious observer with free will and can make rational decisions.\nThe cool thing about it is that unless the player knows that their choices are being predicted, the simplest theory that they can construct is that their choice directly determines the contents of the box, which, of course, cannot be explained by normal physics. And their theory would be correct, in the sense that it would be in line with experimental data.\nAnyway, let me know what you think of this idea. Thanks for reading.\n","date":"5 August 2024","externalUrl":null,"permalink":"/danirybeblog/posts/1722788990551-newcombs-paradox/","section":"Posts","summary":"My thoughts on how to resolve the Newcomb\u0026rsquo;s paradox","title":"Thoughts on Newcomb's paradox","type":"posts"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/categories/haskell/","section":"Categories","summary":"","title":"Haskell","type":"categories"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/tags/type-level-programming/","section":"Tags","summary":"","title":"Type-Level-Programming","type":"tags"},{"content":" Introduction # A few days ago, I stumbled upon this blogpost in which the author proposes a way to restrict the type of binary functions to only allow for ones that are commutative. The key idea is to introduce unordered collections, and no, I\u0026rsquo;m not talking about Sets or Maps or whatever. Those data structures are actually quite ordered, in the sense that they contain the ordering information of their elements:\nData.Set.elems :: Set a -\u0026gt; [a] Data.Map.elems :: Map k a -\u0026gt; [a] The way I want you to think about it is this: if I can get a list from a Set/Map, which contains the ordering information of its elements, then that information must\u0026rsquo;ve already been contained in the original Set/Map!\nBut a truly unordered collection would not have any kind of ordering of its elements whatsoever, while still somehow allowing us to work with them. And any function that takes its arguments in a collection like that would be commutative by default because it wouldn\u0026rsquo;t be able to observe their order. There would be no order to observe.\nA Truly Unordered Collection # The aforementioned blogpost suggests implementing an unordered pair something like this:\nnewtype UnorderedPair a = UP { diffBy :: (a -\u0026gt; Bool) -\u0026gt; Either Bool (a, a) } The idea, is that to access the elements of an unordered pair, we need to first differentiate between them. We supply a function f :: a -\u0026gt; Bool. If it returns different values for the elements of the pair, then we have successfully differentiated between them, and we get them back (Right (a1, a2)) where f a1 == True and f a2 == False. Notice that the ordering of a1 and a2 is completely determined by f and not by any information already present in the UnorderedPair.\nBut if f returns the same value for both elements of the pair, then we have not successfully differentiated between them, and we get back Left False or Left True depending on the result of f.\nBasically, diffBy classifies elements of UnorderedPair using a predicate.\nAnother way to think about this is that we can only observe ordered data, so in order to observe a1 and a2 we need to order them, and that\u0026rsquo;s exactly what f attempts to do.\nAnother interesting analogy is that UnorderedPair a is like two a\u0026rsquo;s superimposed perfectly on top of each other. If you don\u0026rsquo;t know what type they are, then they look the same to you, and there is no way to separate them. That is, unless you can find some sort of difference between them, which is what f does.\nAnyway, now we can write stuff like this:\nand :: UnorderedPair Bool -\u0026gt; Bool and ub = case diffBy ub id of Left True -\u0026gt; True -- both booleans are True Right (b1, b2) -\u0026gt; False -- b1 is True, b2 is False Left False -\u0026gt; False -- both booleans are False or :: UnorderedPair Bool -\u0026gt; Bool or ub = case diffBy ub id of Left True -\u0026gt; True -- both booleans are True Right (b1, b2) -\u0026gt; True -- b1 is True, b2 is False Left False -\u0026gt; False -- both booleans are False Now, as long as we construct unordered pairs correctly, functions and and or are guaranteed to be commutative, just from their type. Cool!\nBut, I hear you ask. What if we need a function that takes in 3 arguments, or 4 arguments, or even\u0026hellip; n arguments? In other words, the next step is to somehow generalize UnorderedPair into a collection that can hold any number of elements.\nUnordered N-tuples # For brevity, I call this collection U for \u0026ldquo;Unordered\u0026rdquo;. Here\u0026rsquo;s how I define it:\n-- type level Nats data Nat = Z | S Nat -- singleton types for Nats data Natural (n :: Nat) where NZ :: Natural Z NS :: Natural n -\u0026gt; Natural (S n) -- type family for adding Nats type family (n :: Nat) :+: (m :: Nat) :: Nat where Z :+: m = m S n :+: m = S (n :+: m) -- result of splitting U based on a predicate data USplit (l :: Nat) a where US :: U n a -\u0026gt; U m a -\u0026gt; USplit (n :+: m) a -- the unordered collection data U (n :: Nat) a where U0 :: U Z a U1 :: a -\u0026gt; U (S Z) a UM :: Natural (S (S n)) -\u0026gt; ((a -\u0026gt; Bool) -\u0026gt; USplit (S (S n)) a) -\u0026gt; U (S (S n)) a The definition of U may seem overly complicated, but it\u0026rsquo;s based on a few basic principles:\nU Z a should be isomorphic to ().\nThat\u0026rsquo;s why U0 exists.\nU (S Z) a should be isomorphic to a.\nThat\u0026rsquo;s why U1 exists.\nIt should be possible to view the size of any U.\nThat\u0026rsquo;s why UM includes a Natural (S (S n)) as its first argument.\nGeneralizing UnorderedPair, we get the ability to split U (n :+: m) a into U n a and U m a, based on a predicate. So we use USplit to hold the results of this splitting. Notice, how this doesn\u0026rsquo;t create any new ordering, except for that which is created by the predicate.\nHere are a few self-explanatory definitions that make working with U easier:\nnatToInt :: Natural n -\u0026gt; Int natToInt NZ = 0 natToInt (NS n) = 1 + natToInt n natAdd :: Natural n -\u0026gt; Natural m -\u0026gt; Natural (n :+: m) natAdd NZ m = m natAdd (NS n) m = NS (natAdd n m) unatlen :: U n a -\u0026gt; Natural n unatlen U0 = NZ unatlen (U1 _) = NS NZ unatlen (UM n _) = n ulen :: U n a -\u0026gt; Int ulen = natToInt . unatlen unull :: U n a -\u0026gt; Bool unull U0 = True unull _ = False upush :: a -\u0026gt; U n a -\u0026gt; U (S n) a upush a U0 = U1 a upush a u@(U1 b) = UM (NS (NS NZ)) \\g -\u0026gt; case (g a, g b) of (True, True) -\u0026gt; US (upush a u) U0 (True, False) -\u0026gt; US (U1 a) (U1 b) (False, True) -\u0026gt; US (U1 b) (U1 a) (False, False) -\u0026gt; US U0 (upush a u) upush a (UM n f) = UM (NS n) \\g -\u0026gt; case (f g, g a) of (US ts fs, True) -\u0026gt; US (upush a ts) fs (US ts fs, False) -\u0026gt; unsafeCoerce $ US ts (upush a fs) -- Btw, I use unsafeCoerce in the definition of upush -- but it\u0026#39;s justified in this case. -- GHC is just too stupid to type check my code. -- Or, more probably, I\u0026#39;m too stupid to write code that GHC can type check. And here are a few not-so-self-explanatory ones:\n-- very useful, super general function ufold :: b -- if U is empty -\u0026gt; (a -\u0026gt; b) -- if U has one element -\u0026gt; (a -\u0026gt; Bool) -- predicate to split with -\u0026gt; (USplit n a -\u0026gt; b) -- split handler -\u0026gt; U n a -\u0026gt; b ufold if0 if1 pred splitHandler u = case u of U0 -\u0026gt; if0 U1 a -\u0026gt; if1 a UM _ splitter -\u0026gt; splitHandler (splitter pred) -- Vec type data Vec (n :: Nat) a where VNil :: Vec Z a (:\u0026gt;) :: a -\u0026gt; Vec n a -\u0026gt; Vec (S n) a infixr 5 :\u0026gt; -- \u0026#34;forgetful\u0026#34; function -- forgets the ordering of elements in Vec unorder :: Vec n a -\u0026gt; U n a unorder VNil = U0 unorder (a :\u0026gt; as) = upush a (unorder as) -- forgets the length of Vec unlength :: (forall n . Vec n a -\u0026gt; b) -\u0026gt; [a] -\u0026gt; b unlength f [] = f VNil unlength f (a : as) = unlength (f . (a :\u0026gt;)) as -- unfucks your polymorphic (guaranteed to be commutative) function. unfuck :: (forall n . U n a -\u0026gt; b) -\u0026gt; [a] -\u0026gt; b unfuck f = unlength (f . unorder) So now we have an unordered collection U that can hold any number of elements and a full arsenal of functions to work with it. I\u0026rsquo;m not sure if it\u0026rsquo;s a good idea to go out of my comfort zone like that, but I think I want to try writing some actually executable code!\nExamples # -- boolean operations andU :: U n Bool -\u0026gt; Bool andU = ufold True id id \\(US ts fs) -\u0026gt; unull fs and2 :: U (S (S Z)) Bool -\u0026gt; Bool and2 = andU -- \u0026gt;\u0026gt;\u0026gt; and2 $ unorder (True :\u0026gt; False :\u0026gt; VNil) -- False and :: [Bool] -\u0026gt; Bool and = unfuck andU orU :: U n Bool -\u0026gt; Bool orU = ufold False id id \\(US ts fs) -\u0026gt; not (unull ts) or2 :: U (S (S Z)) Bool -\u0026gt; Bool or2 = orU -- \u0026gt;\u0026gt;\u0026gt; or2 $ unorder (True :\u0026gt; False :\u0026gt; VNil) -- True or :: [Bool] -\u0026gt; Bool or = unfuck orU -- adding function add :: [Int] -\u0026gt; Int add = unfuck addU where addU :: U n Int -\u0026gt; Int addU = ufold 0 id (\u0026lt; 0) \\(US neg nonNeg) -\u0026gt; addNonNeg nonNeg - addPos (negate \u0026lt;$\u0026gt; neg) addNonNeg :: U n Int -\u0026gt; Int addNonNeg = ufold 0 id (== 0) \\(US _ p) -\u0026gt; addPos p addPos :: U n Int -\u0026gt; Int addPos = ufold 0 id even \\(US e o) -\u0026gt; let e\u0026#39; = (`div` 2) \u0026lt;$\u0026gt; e o\u0026#39; = (`div` 2) \u0026lt;$\u0026gt; o in 2 * addNonNeg e\u0026#39; + ulen o + 2 * addNonNeg o\u0026#39; -- \u0026gt;\u0026gt;\u0026gt; add [1, 2, 3, 4 , 5] -- 15 This is actually pretty fun. Not practical, but fun. Writing add was kinda like solving a puzzle. You need to figure out what property of inputs you can use to split them on. Here, I was able to use dvisibility by 2, but I\u0026rsquo;m not sure how to, for example, write a function that multiplies the inputs.\nFuture work # Here, I outline some of the things I wanted to do, but couldn\u0026rsquo;t figure out how to:\nProve that any commutative function can be rewritten using U. Or prove otherwise. Prove that U in fact, doesn\u0026rsquo;t have any ordering information.\nThis seems intuitive to me, but never the less, a formal proof would be nice. See if ubind :: U n (U m a) -\u0026gt; U (n :*: m) a is possible to implement.\nThis would make U a kind of \u0026ldquo;parametrized monad-like\u0026rdquo;. Find any practical applications for anything I\u0026rsquo;ve ever written :) P.S. # Oh, and if you want to play around with this, you can find all the code here.\n","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/posts/unordered-n-tuples/","section":"Posts","summary":"Defining a type of unordered containers and using it to write commutative functions","title":"Unordered Homogeneous N-tuples for Guaranteed Commutativity","type":"posts"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/danirybeblog/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/danirybeblog/series/","section":"Series","summary":"","title":"Series","type":"series"}]