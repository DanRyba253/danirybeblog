
[{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/","section":"Dani Rybe's Blog","summary":"","title":"Dani Rybe's Blog","type":"page"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/categories/haskell/","section":"Categories","summary":"","title":"Haskell","type":"categories"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/tags/type-level-programming/","section":"Tags","summary":"","title":"Type-Level-Programming","type":"tags"},{"content":" Introduction # A few days ago, I stumbled upon this blogpost in which the author proposes a way to restrict the type of binary functions to only allow for ones that are commutative. The key idea is to introduce unordered collections, and no, I\u0026rsquo;m not talking about Sets or Maps or whatever. Those data structures are actually quite ordered, in the sense that they contain the ordering information of their elements:\nData.Set.elems :: Set a -\u0026gt; [a] Data.Map.elems :: Map k a -\u0026gt; [a] The way I want you to think about it is this: if I can get a list from a Set/Map, which contains the ordering information of its elements, then that information must\u0026rsquo;ve already been contained in the original Set/Map!\nBut a truly unordered collection would not have any kind of ordering of its elements whatsoever, while still somehow allowing us to work with them. And any function that takes its arguments in a collection like that would be commutative by default because it wouldn\u0026rsquo;t be able to observe their order. There would be no order to observe.\nA Truly Unordered Collection # The aforementioned blogpost suggests implementing an unordered pair something like this:\nnewtype UnorderedPair a = UP { diffBy :: (a -\u0026gt; Bool) -\u0026gt; Either Bool (a, a) } The idea, is that to access the elements of an unordered pair, we need to first differentiate between them. We supply a function f :: a -\u0026gt; Bool. If it returns different values for the elements of the pair, then we have successfully differentiated between them, and we get them back (Right (a1, a2)) where f a1 == True and f a2 == False. Notice that the ordering of a1 and a2 is completely determined by f and not by any information already present in the UnorderedPair.\nBut if f returns the same value for both elements of the pair, then we have not successfully differentiated between them, and we get back Left False or Left True depending on the result of f.\nBasically, diffBy classifies elements of UnorderedPair using a predicate.\nAnother way to think about this is that we can only observe ordered data, so in order to observe a1 and a2 we need to order them, and that\u0026rsquo;s exactly what f attempts to do.\nAnother interesting analogy is that UnorderedPair a is like two a\u0026rsquo;s superimposed perfectly on top of each other. If you don\u0026rsquo;t know what type they are, then they look the same to you, and there is no way to separate them. That is, unless you can find some sort of difference between them, which is what f does.\nAnyway, now we can write stuff like this:\nand :: UnorderedPair Bool -\u0026gt; Bool and ub = case diffBy ub id of Left True -\u0026gt; True -- both booleans are True Right (b1, b2) -\u0026gt; False -- b1 is True, b2 is False Left False -\u0026gt; False -- both booleans are False or :: UnorderedPair Bool -\u0026gt; Bool or ub = case diffBy ub id of Left True -\u0026gt; True -- both booleans are True Right (b1, b2) -\u0026gt; True -- b1 is True, b2 is False Left False -\u0026gt; False -- both booleans are False Now, as long as we construct unordered pairs correctly, functions and and or are guaranteed to be commutative, just from their type. Cool!\nBut, I hear you ask. What if we need a function that takes in 3 arguments, or 4 arguments, or even\u0026hellip; n arguments? In other words, the next step is to somehow generalize UnorderedPair into a collection that can hold any number of elements.\nUnordered N-tuples # For brevity, I call this collection U for \u0026ldquo;Unordered\u0026rdquo;. Here\u0026rsquo;s how I define it:\n-- type level Nats data Nat = Z | S Nat -- singleton types for Nats data Natural (n :: Nat) where NZ :: Natural Z NS :: Natural n -\u0026gt; Natural (S n) -- type family for adding Nats type family (n :: Nat) :+: (m :: Nat) :: Nat where Z :+: m = m S n :+: m = S (n :+: m) -- result of splitting U based on a predicate data USplit (l :: Nat) a where US :: U n a -\u0026gt; U m a -\u0026gt; USplit (n :+: m) a -- the unordered collection data U (n :: Nat) a where U0 :: U Z a U1 :: a -\u0026gt; U (S Z) a UM :: Natural (S (S n)) -\u0026gt; ((a -\u0026gt; Bool) -\u0026gt; USplit (S (S n)) a) -\u0026gt; U (S (S n)) a The definition of U may seem overly complicated, but it\u0026rsquo;s based on a few basic principles:\nU Z a should be isomorphic to ().\nThat\u0026rsquo;s why U0 exists.\nU (S Z) a should be isomorphic to a.\nThat\u0026rsquo;s why U1 exists.\nIt should be possible to view the size of any U.\nThat\u0026rsquo;s why UM includes a Natural (S (S n)) as its first argument.\nGeneralizing UnorderedPair, we get the ability to split U (n :+: m) a into U n a and U m a, based on a predicate. So we use USplit to hold the results of this splitting. Notice, how this doesn\u0026rsquo;t create any new ordering, except for that which is created by the predicate.\nHere are a few self-explanatory definitions that make working with U easier:\nnatToInt :: Natural n -\u0026gt; Int natToInt NZ = 0 natToInt (NS n) = 1 + natToInt n natAdd :: Natural n -\u0026gt; Natural m -\u0026gt; Natural (n :+: m) natAdd NZ m = m natAdd (NS n) m = NS (natAdd n m) unatlen :: U n a -\u0026gt; Natural n unatlen U0 = NZ unatlen (U1 _) = NS NZ unatlen (UM n _) = n ulen :: U n a -\u0026gt; Int ulen = natToInt . unatlen unull :: U n a -\u0026gt; Bool unull U0 = True unull _ = False upush :: a -\u0026gt; U n a -\u0026gt; U (S n) a upush a U0 = U1 a upush a u@(U1 b) = UM (NS (NS NZ)) \\g -\u0026gt; case (g a, g b) of (True, True) -\u0026gt; US (upush a u) U0 (True, False) -\u0026gt; US (U1 a) (U1 b) (False, True) -\u0026gt; US (U1 b) (U1 a) (False, False) -\u0026gt; US U0 (upush a u) upush a (UM n f) = UM (NS n) \\g -\u0026gt; case (f g, g a) of (US ts fs, True) -\u0026gt; US (upush a ts) fs (US ts fs, False) -\u0026gt; unsafeCoerce $ US ts (upush a fs) -- Btw, I use unsafeCoerce in the definition of upush -- but it\u0026#39;s justified in this case. -- GHC is just too stupid to type check my code. -- Or, more probably, I\u0026#39;m too stupid to write code that GHC can type check. And here are a few not-so-self-explanatory ones:\n-- very useful, super general function ufold :: b -- if U is empty -\u0026gt; (a -\u0026gt; b) -- if U has one element -\u0026gt; (a -\u0026gt; Bool) -- predicate to split with -\u0026gt; (USplit n a -\u0026gt; b) -- split handler -\u0026gt; U n a -\u0026gt; b ufold if0 if1 pred splitHandler u = case u of U0 -\u0026gt; if0 U1 a -\u0026gt; if1 a UM _ splitter -\u0026gt; splitHandler (splitter pred) -- Vec type data Vec (n :: Nat) a where VNil :: Vec Z a (:\u0026gt;) :: a -\u0026gt; Vec n a -\u0026gt; Vec (S n) a infixr 5 :\u0026gt; -- \u0026#34;forgetful\u0026#34; function -- forgets the ordering of elements in Vec unorder :: Vec n a -\u0026gt; U n a unorder VNil = U0 unorder (a :\u0026gt; as) = upush a (unorder as) -- forgets the length of Vec unlength :: (forall n . Vec n a -\u0026gt; b) -\u0026gt; [a] -\u0026gt; b unlength f [] = f VNil unlength f (a : as) = unlength (f . (a :\u0026gt;)) as -- unfucks your polymorphic (guaranteed to be commutative) function. unfuck :: (forall n . U n a -\u0026gt; b) -\u0026gt; [a] -\u0026gt; b unfuck f = unlength (f . unorder) So now we have an unordered collection U that can hold any number of elements and a full arsenal of functions to work with it. I\u0026rsquo;m not sure if it\u0026rsquo;s a good idea to go out of my comfort zone like that, but I think I want to try writing some actually executable code!\nExamples # -- boolean operations andU :: U n Bool -\u0026gt; Bool andU = ufold True id id \\(US ts fs) -\u0026gt; unull fs and2 :: U (S (S Z)) Bool -\u0026gt; Bool and2 = andU -- \u0026gt;\u0026gt;\u0026gt; and2 $ unorder (True :\u0026gt; False :\u0026gt; VNil) -- False and :: [Bool] -\u0026gt; Bool and = unfuck andU orU :: U n Bool -\u0026gt; Bool orU = ufold False id id \\(US ts fs) -\u0026gt; not (unull ts) or2 :: U (S (S Z)) Bool -\u0026gt; Bool or2 = orU -- \u0026gt;\u0026gt;\u0026gt; or2 $ unorder (True :\u0026gt; False :\u0026gt; VNil) -- True or :: [Bool] -\u0026gt; Bool or = unfuck orU -- adding function add :: [Int] -\u0026gt; Int add = unfuck addU where addU :: U n Int -\u0026gt; Int addU = ufold 0 id (\u0026lt; 0) \\(US neg nonNeg) -\u0026gt; addNonNeg nonNeg - addPos (negate \u0026lt;$\u0026gt; neg) addNonNeg :: U n Int -\u0026gt; Int addNonNeg = ufold 0 id (== 0) \\(US _ p) -\u0026gt; addPos p addPos :: U n Int -\u0026gt; Int addPos = ufold 0 id even \\(US e o) -\u0026gt; let e\u0026#39; = (`div` 2) \u0026lt;$\u0026gt; e o\u0026#39; = (`div` 2) \u0026lt;$\u0026gt; o in 2 * addNonNeg e\u0026#39; + ulen o + 2 * addNonNeg o\u0026#39; -- \u0026gt;\u0026gt;\u0026gt; add [1, 2, 3, 4 , 5] -- 15 This is actually pretty fun. Not practical, but fun. Writing add was kinda like solving a puzzle. You need to figure out what property of inputs you can use to split them on. Here, I was able to use dvisibility by 2, but I\u0026rsquo;m not sure how to, for example, write a function that multiplies the inputs.\nFuture work # Here, I outline some of the things I wanted to do, but couldn\u0026rsquo;t figure out how to:\nProve that any commutative function can be rewritten using U. Or prove otherwise. Prove that U in fact, doesn\u0026rsquo;t have any ordering information.\nThis seems intuitive to me, but never the less, a formal proof would be nice. See if ubind :: U n (U m a) -\u0026gt; U (n :*: m) a is possible to implement.\nThis would make U a kind of \u0026ldquo;parametrized monad-like\u0026rdquo;. Find any practical applications for anything I\u0026rsquo;ve ever written :) P.S. # Oh, and if you want to play around with this, you can find all the code here.\n","date":"17 June 2024","externalUrl":null,"permalink":"/danirybeblog/posts/unordered-n-tuples/","section":"Posts","summary":"Defining a type of unordered containers and using it to write commutative functions","title":"Unordered Homogenous N-tuples for guaranteed commutativity","type":"posts"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/danirybeblog/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","date":"1 January 0001","externalUrl":null,"permalink":"/danirybeblog/series/","section":"Series","summary":"","title":"Series","type":"series"}]